package a2b.core.accelerators;

import java.awt.AWTException;
import java.awt.Robot;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import org.apache.commons.io.FileUtils;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.Keys;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebDriverException;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.firefox.FirefoxProfile;
import org.openqa.selenium.ie.InternetExplorerDriver;
import org.openqa.selenium.ie.InternetExplorerOptions;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.remote.CapabilityType;
import org.openqa.selenium.remote.DesiredCapabilities;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.safari.SafariDriver;
import org.openqa.selenium.support.events.EventFiringWebDriver;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.Select;
import org.openqa.selenium.support.ui.WebDriverWait;

import a2b.config.gblConstants;
import a2b.core.listeners.WebDriverListener;
import a2b.core.logs.LogManager;

public class WebActionEngine  {

	//Declare Drivers
	public WebDriver webDriver = null;
	public EventFiringWebDriver driver = null;
	public RemoteWebDriver remoteDriver = null;    

	//Declare Loggers
	private final String logClassName = "ActionEngine";

	//Declare log msg strings
	private final String msgClickSuccess = "Successfully Clicked On ";
	private final String msgClickFailure = "Unable To Click On ";
	private final String msgTypeSuccess = "Successfully Typed On ";
	private final String msgTypeFailure = "Unable To Type On ";
	private final String msgIsElementFoundSuccess = "Successfully Found Element ";
	private final String msgIsElementFoundFailure = "Unable To Found Element ";    


	public EventFiringWebDriver getDriver(){
		return this.driver;
	}

	public void closeDriver(){
		try{
			this.driver.quit();    		
			Thread.sleep(gblConstants.defSleepTime);
        	LogManager.logInfo(WebActionEngine.class.getName(), "Closed web driver");
		}catch(Exception e){
    		LogManager.logException(e, WebActionEngine.class.getName(), "Exception to close web driver");
		}
	}

	public RemoteWebDriver getRemoteDriver(){
		return this.remoteDriver;
	}

	public EventFiringWebDriver setWebdriverForGrid(String strServerIP, String strServerPortNo, String browser) throws MalformedURLException {
		DesiredCapabilities caps = new DesiredCapabilities();
		if (browser.trim().equalsIgnoreCase("IE")) {
			caps = DesiredCapabilities.internetExplorer();
		} else if (browser.trim().equalsIgnoreCase("Firefox")) {
			caps = DesiredCapabilities.firefox();
		} else if (browser.trim().equalsIgnoreCase("chrome")) {
			caps = DesiredCapabilities.chrome();
		} else {
			caps = DesiredCapabilities.safari();
		}
		//String Node = "http://172.16.6.5:4444/wd/hub";
		String Node = "http://"+ strServerIP + ":" + strServerPortNo + "/wd/hub";
		//URL commandExecutorUri = new URL("http://ondemand.saucelabs.com/wd/hub");
		webDriver = new RemoteWebDriver(new URL(Node), caps);
		driver = new EventFiringWebDriver(this.webDriver);
		WebDriverListener myListener = new WebDriverListener();
		driver.register(myListener);        
		return driver;
	}

	public EventFiringWebDriver setWebDriverForLocal(String browser) throws IOException, InterruptedException {

		switch (browser.trim().toLowerCase()) {
		case "firefox":
			System.setProperty("webdriver.gecko.driver", gblConstants.firefoxDriverPath);
			
			FirefoxProfile ffProfile = new FirefoxProfile();
			ffProfile.setPreference("browser.download.dir", gblConstants.downloadsPath);
			ffProfile.setPreference("browser.download.folderList", 2);
			ffProfile.setPreference("browser.helperApps.neverAsk.saveToDisk", "application/pdf;"); 
			ffProfile.setPreference("pdfjs.disabled", true);
			ffProfile.setPreference("pdfjs.enabledCache.state", false);
			
			FirefoxOptions ffoptions = new FirefoxOptions().setProfile(ffProfile);
			
			webDriver = new FirefoxDriver(ffoptions);
			
			//webDriver = new FirefoxDriver();
			
			break;
		case "internet explorer":
		case "internetexplorer":
		case "ie":

			InternetExplorerOptions ieOptions = new InternetExplorerOptions();
        	ieOptions.setCapability(InternetExplorerDriver.INTRODUCE_FLAKINESS_BY_IGNORING_SECURITY_DOMAINS, true);
        	ieOptions.setCapability(InternetExplorerDriver.UNEXPECTED_ALERT_BEHAVIOR, true);
        	ieOptions.setCapability(InternetExplorerDriver.REQUIRE_WINDOW_FOCUS, true); 
        	ieOptions.setCapability(InternetExplorerDriver.IGNORE_ZOOM_SETTING, true);
        	ieOptions.setCapability(InternetExplorerDriver.ENABLE_PERSISTENT_HOVERING, false);
        	ieOptions.setCapability(InternetExplorerDriver.NATIVE_EVENTS, true);
        	ieOptions.setCapability(InternetExplorerDriver.ENABLE_ELEMENT_CACHE_CLEANUP, true);
        	//ieOptions.setCapability(InternetExplorerDriver.FORCE_CREATE_PROCESS, true);
        	//ieOptions.setCapability(InternetExplorerDriver.FORCE_CREATE_PROCESS, true);
        	ieOptions.setCapability(CapabilityType.ACCEPT_SSL_CERTS, true);   

			//Clear browsing history
			Process p = Runtime
						.getRuntime()
						.exec("RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 255");
			p.waitFor();	

			File driverExe = new File(gblConstants.ieDriverPath);
            System.setProperty("webdriver.ie.driver", driverExe.getAbsolutePath());
            webDriver = new InternetExplorerDriver(ieOptions);
            Thread.sleep(1000);
           
            break;

		case "chrome":
			System.setProperty("webdriver.chrome.driver", gblConstants.chromeDriverPath);
			//DesiredCapabilities chromeCaps = DesiredCapabilities.chrome();
			ChromeOptions options = new ChromeOptions();
			options.addArguments("test-type");
                options.addArguments("--disable-extensions");                
			options.addArguments("--dns-prefetch-disable");
			options.addArguments("--start-maximized");
                options.addArguments("--disable-infobars");
			//chromeCaps.setCapability(ChromeOptions.CAPABILITY, options);
                
                Map<String, Object> prefs = new LinkedHashMap<>();
                prefs.put("plugins.always_open_pdf_externally", true);
                prefs.put("download.default_directory", gblConstants.downloadsPath);
                options.setExperimentalOption("prefs", prefs);

			//webDriver = new ChromeDriver(chromeCaps);
			webDriver = new ChromeDriver(options);
 
			break;

		case "Safari":
			webDriver = new SafariDriver();

			/*	for(int i=1;i<=10;i++){

						try{
							WebDriver driver=new SafariDriver();
							//WebDriver=new SafariDriver();

							break;
						}catch(Exception e1){
							Runtime.getRuntime().exec("taskkill /F /IM Safari.exe");
							Thread.sleep(3000);
							Runtime.getRuntime().exec("taskkill /F /IM plugin-container.exe");
							Runtime.getRuntime().exec("taskkill /F /IM WerFault.exe"); 

							continue;   

						}

					}*/
		}
		driver = new EventFiringWebDriver(this.webDriver);
		WebDriverListener myListener = new WebDriverListener();
		driver.register(myListener); 

		return this.driver;
	}

	public void setRemoteWebDriverForCloudSauceLabs() throws IOException, InterruptedException {
		//        if (this.browser.equalsIgnoreCase("Safari")) {
		//            DesiredCapabilities desiredCapabilities = new DesiredCapabilities();
		//            desiredCapabilities.setCapability(CapabilityType.BROWSER_NAME, this.browser);
		//            desiredCapabilities.setCapability(CapabilityType.VERSION, this.version);
		//            desiredCapabilities.setCapability(CapabilityType.PLATFORM, this.platform);
		//            desiredCapabilities.setCapability("username", this.userName);
		//            desiredCapabilities.setCapability("accessKey", this.accessKey);
		//            desiredCapabilities.setCapability("accessKey", this.accessKey);
		//            desiredCapabilities.setCapability("name", this.executedFrom + " - " /*+ this.jobName + " - " + this.buildNumber*/ + this.platform + " - " + this.browser);
		//            URL commandExecutorUri = new URL("http://ondemand.saucelabs.com/wd/hub");
		//            for (int i = 1; i <= 10; i++) {
		//
		//                try {
		//                    this.WebDriver = new RemoteWebDriver(commandExecutorUri, desiredCapabilities);
		//
		//                    break;
		//                } catch (Exception e1) {
		//                    Runtime.getRuntime().exec("taskkill /F /IM Safari.exe");
		//                    Thread.sleep(3000);
		//                    Runtime.getRuntime().exec("taskkill /F /IM plugin-container.exe");
		//                    Runtime.getRuntime().exec("taskkill /F /IM WerFault.exe");
		//
		//                    continue;
		//
		//                }
		//            }
		//        } else {
		//
		//            DesiredCapabilities desiredCapabilities = new DesiredCapabilities();
		//            desiredCapabilities.setCapability(CapabilityType.BROWSER_NAME, this.browser);
		//            desiredCapabilities.setCapability(CapabilityType.VERSION, this.version);
		//            desiredCapabilities.setCapability(CapabilityType.PLATFORM, this.platform);
		//            desiredCapabilities.setCapability("username", this.userName);
		//            desiredCapabilities.setCapability("accessKey", this.accessKey);
		//            desiredCapabilities.setCapability("accessKey", this.accessKey);
		//            desiredCapabilities.setCapability("name", this.executedFrom + " - " /*+ this.jobName + " - " + this.buildNumber*/ + this.platform + " - " + this.browser);
		//            URL commandExecutorUri = new URL("http://ondemand.saucelabs.com/wd/hub");
		//            this.WebDriver = new RemoteWebDriver(commandExecutorUri, desiredCapabilities);
		//            this.Driver = new EventFiringWebDriver(this.WebDriver);
		//            WebDriverListener myListener = new WebDriverListener();
		//            this.Driver.register(myListener);               
		//        }
	}    

	public boolean loadPage(String pageUrl, String strExpTitle) {
		try{
			this.driver.manage().window().maximize();
			this.driver.get(pageUrl);
			this.driver.manage().timeouts().pageLoadTimeout(gblConstants.pageLoadTimeout, TimeUnit.SECONDS);
			this.driver.manage().timeouts().implicitlyWait(gblConstants.implicitWaitTimeout, TimeUnit.SECONDS);
			
			String strActTitle = this.driver.getTitle().trim();
			
			System.out.println("strActTitle = " + strActTitle);
			System.out.println("strExpTitle = " + strExpTitle);
			
			if(strActTitle.equalsIgnoreCase(strExpTitle.trim())){
				return true;
			}else{
				return false;
			}    		
		}catch(WebDriverException e){
    		LogManager.logException(e, WebActionEngine.class.getName(), "Exception to load web page using url " + pageUrl);
			return false;
		}
	}

	public boolean selectByIndex(By locator, int index, String locatorName)  {
		boolean blnRes = false;
		try {
			Select selElement = new Select(driver.findElement(locator));
			selElement.selectByIndex(index);

			List<WebElement> options = selElement.getOptions();
			WebElement seletedOption = selElement.getFirstSelectedOption();

			for(int cntr=0;cntr<options.size();cntr++){
				if (seletedOption.getText().trim().equalsIgnoreCase( options.get(cntr).getText().trim() )) {
            		LogManager.logInfo(WebActionEngine.class.getName(), 
							"Successfully selected option " + seletedOption.getText() + " using index " + index + " from " + locatorName);
					blnRes = true;
					break;
				}else{
					blnRes = false;            		
				}
			}            
		}catch (Exception e) {
        	LogManager.logException(e, logClassName, "Unable to select index " + index + " from " + locatorName);
    		LogManager.logInfo(WebActionEngine.class.getName(), 
					"Failed to select option at index " + index + " from " + locatorName);        	
			blnRes = false;
		} 
		return blnRes;
	}

	public boolean selectByName(String locator, String optionName, String eleName){
		boolean blnRes = false;

		try{
			Select selElement = new Select(getElement(locator));
			List<WebElement> options = selElement.getOptions();
			for(WebElement option:options){
				if (option.getText().trim().equalsIgnoreCase(optionName.trim())){
					option.click();
					blnRes = true;
    				LogManager.logInfo(WebActionEngine.class.getName(), "Successfully selected option - " + optionName + " from " + eleName);
					break;
				}
			}
			//selElement.selectByVisibleText(optionName);
		}catch(Exception e){
			blnRes = false;
    		LogManager.logException(e, WebActionEngine.class.getName(), "Exception to select option " + optionName + " from " + eleName);
		}
		return blnRes;
	}
    
	public boolean click(By locator, String locatorName) throws Exception {
		boolean status = false;
		try {            
			WebElement ele = this.driver.findElement(locator);
			scrollElementIntoView(ele);
			if (ele.isDisplayed() && ele.isEnabled()){
				ele.click();
				status = true;
                LogManager.logInfo(logClassName, this.msgClickSuccess + locatorName);            
			}
		} catch (Exception e) {
			status = false;
            LogManager.logException(e, logClassName, this.msgClickFailure + locatorName);
			throw e;
		}
		return status;
	}

	public boolean click(String locator, String elementName) throws Exception {
		boolean status = false;
		try {
			waitForElementPresent(locator, gblConstants.wdWaitTimeout);
			WebElement ele = getElement(locator);
			//scrollElementIntoView(locator);
			if (ele.isDisplayed() && ele.isEnabled()){
				ele.click();
				status = true;
                LogManager.logInfo(logClassName, this.msgClickSuccess + elementName);
			}
		} catch (Exception e) {
			status = false;
            LogManager.logException(e, logClassName, this.msgClickFailure + elementName);
			throw e;
		}
		return status;
	}    

	public boolean waitAndClick(String locator, String locatorName) throws Exception {
		boolean status = false;
		try {
			WebDriverWait wait = new WebDriverWait(driver, gblConstants.wdWaitTimeout);
			By eleLocator = byLocator(locator);
			WebElement ele = wait.until(ExpectedConditions.elementToBeClickable(eleLocator));

			if (ele.isDisplayed() && ele.isEnabled()){
				ele.click();
				status = true;
            	LogManager.logInfo(logClassName, this.msgClickSuccess + locatorName);
			}
		} catch (Exception e) {
			status = false;            
            LogManager.logException(e, logClassName, this.msgClickFailure + locatorName);
			throw e;
		}
		return status;
	}

	public boolean clickUsingEnter(String locator, String elementName) throws Exception {
		boolean status = false;
		try {
			WebElement ele = getElement(locator);
			scrollElementIntoView(locator);
			if (ele.isDisplayed() && ele.isEnabled()){
				ele.sendKeys(Keys.ENTER);
				status = true; 
				try {
					Thread.sleep(1000);
					if (ele.isDisplayed() && ele.isEnabled())
						ele.sendKeys(Keys.ENTER);
				} catch (Exception e) {
					
				}
				LogManager.logInfo(logClassName, this.msgClickSuccess + elementName);
			}
		} catch (Exception e) {
			status = false;
			LogManager.logException(e, logClassName, this.msgClickFailure + elementName);
			throw e;
		}
		return status;
	}    

	/**
	 * If more than one element present
	 *
	 * @param locator
	 * @param index
	 * @return
	 * @throws Throwable
	 */
	public boolean click(By locator, int index, String locatorName)  {
		boolean status = false;
		try {
			WebElement ele = this.driver.findElements(locator).get(index);
			scrollElementIntoView(ele);
			if (ele.isDisplayed() && ele.isEnabled()){
				ele.click();
				status = true;
            	LogManager.logInfo(logClassName, this.msgClickSuccess + locatorName);
			}
		} catch (Exception e) {
			status = false;
            LogManager.logException(e, logClassName, this.msgClickFailure + locatorName);            
		}
		return status;
	}

	public boolean clickusingJavaScript(String locator) {
		boolean blnRes = false;
		try{
			Thread.sleep(gblConstants.defSleepTime);
			WebElement element = this.driver.findElement(byLocator(locator));
			JavascriptExecutor executor = (JavascriptExecutor) driver;
			executor.executeScript("arguments[0].click();", element);
            LogManager.logInfo(logClassName, "Used java script executor to click element " + locator);
			blnRes = true;
		}catch(Exception e){
			blnRes = false;
        	LogManager.logError(logClassName, "Unable to click " + locator + " using java script executor" + locator);
		}
		return blnRes;
	}

	public void runJavaScriptMethod(String exeJavaScript){
		JavascriptExecutor executor = (JavascriptExecutor) driver;
		executor.executeScript(exeJavaScript, "");
	}

	public boolean isElementPresent(String locator, String locatorName, boolean expected)  {
		boolean status = false;
		try {
			WebElement ele = getElement(locator);
			status = (ele.isDisplayed())? true : false;
		} catch (Exception e) {
			status = false;
		}
		if (!(expected ^ status)) {
			status = true;
            LogManager.logInfo(logClassName, this.msgIsElementFoundSuccess + locatorName + " displayed as " + expected);                
		} else {
			status = false;
        	LogManager.logError(logClassName, this.msgIsElementFoundFailure + locatorName + " displayed as " + expected);
		}        
		return status;
	}
	
	/**
	 * Check If Field is Enabled
	 * @param locator
	 * @param locatorName
	 * @return
	 */
	public boolean isElementEnabled(String locator,String locatorName, boolean expected) {
		boolean status = false;
		try {
			WebElement ele = getElement(locator);
			status = (ele.isEnabled())? true : false;

			if (!(expected ^ status)) {
				status = true;
	            LogManager.logInfo(logClassName, this.msgIsElementFoundSuccess + locatorName + " enabled status as " + expected);                
			} else {
				status = false;
	        	LogManager.logError(logClassName, this.msgIsElementFoundFailure + locatorName + " enabled status as " + expected);
			}  			
		} catch (Exception e) {
			status = false;
		}
		return status;
	}	
	
	/**
	 * Switch to frame
	 * @return
	 */
	public boolean switchToIFrame() {
		boolean flag=false;
		try {
			WebElement iframe =	this.driver.findElement(By.tagName("iframe"));
			this.driver.switchTo().frame(iframe);
			flag=true;
		}catch(Exception e) {
			flag=false;
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to swith to frame");
			e.printStackTrace();
		}
		return flag;
	}
	
	/**
	 * Wait for js to load
	 * @return
	 */
	public Boolean waitForJStoLoad() {
		boolean flag=false;
		JavascriptExecutor  js = (JavascriptExecutor) driver;
		String   pageLoadStatus = (String)js.executeScript("return document.readyState");

		if(pageLoadStatus.equals("complete")) {
			flag=true;
		}else {
			return flag;
		}
		return flag;
	}	

	public boolean type(By locator, String testdata, String locatorName)  {
		boolean status = false;
		try {
			WebElement ele = driver.findElement(locator);
			ele.clear();
			ele.sendKeys(testdata);

			String strActValue = ele.getAttribute("value").trim(); 
			if (strActValue.equals(testdata)){
				status = true;
            	LogManager.logInfo(logClassName, this.msgTypeSuccess + locatorName);
			}
		} catch (Exception e) {
			status = false;            
            LogManager.logException(e, logClassName, this.msgTypeFailure + locatorName);
		}
		return status;
	}

	public boolean setCheckbox(String locator, boolean blnEnabled, String locatorName){
		boolean blnRes = false;
		WebElement ele = getElement(locator);    	
		if (ele.isSelected() ^ blnEnabled) {
			ele.click();
			blnRes = true;
    		LogManager.logInfo(WebActionEngine.class.getName(), "Successfully updated checkbox " + locatorName + " as "+ blnEnabled);
		}
		return blnRes;
	}

	/**
	 * Moves the mouse to the middle of the element. The element is scrolled
	 * into view and its location is calculated using getBoundingClientRect.
	 *
	 * @param locator     : Action to be performed on element (Get it from Object
	 *                    repository)
	 * @param locatorName : Meaningful name to the element (Ex:link,menus etc..)
	 */
	synchronized public boolean mouseHover(String locator, String locatorName) {
		boolean flag = false;
		try {
			WebElement mo = getElement(locator);
			new Actions(this.driver).moveToElement(mo).build().perform();
			flag = true;
            LogManager.logInfo(WebActionEngine.class.getName(), "MouseOver action is performed on " + locatorName);
		} catch (Exception e) {
        	LogManager.logException(e, logClassName, "MouseOver action is not perform on " + locatorName);
			return false;
		}
		return flag;
	}

	synchronized public boolean mouseClick(String locator, String locatorName) {
		boolean flag = false;
		try {
			WebElement ele = getElement(locator);
			new Actions(this.driver).click(ele).build().perform();
			Thread.sleep(gblConstants.defSleepTime/2);
			flag = true;
            LogManager.logInfo(WebActionEngine.class.getName(), "MouseOver action is performed on " + locatorName);
		} catch (Exception e) {
        	LogManager.logException(e, logClassName, "MouseOver action is not perform on " + locatorName);
			return false;
		}
		return flag;
	}

	public void sleep(int time) {
		try{
			Thread.sleep(time);        	
		}catch(InterruptedException ie){
			System.out.println("Exception to sleep for " + time + " msec");
		}
	}

	public boolean waitForElementPresent(By by, String locator, int secs)  {
		boolean status = false;

		try {

			WebDriverWait wait = new WebDriverWait(this.driver, 60);
			wait.until(ExpectedConditions.elementToBeClickable(by));
			/*((JavascriptExecutor) Driver).executeScript(
					"arguments[0].scrollIntoView();", by);*/

			for (int i = 0; i < secs / 2; i++) {
				List<WebElement> elements = this.driver.findElements(by);
				if (elements.size() > 0) {
					status = true;
					return status;

				} else {
					this.driver.manage().timeouts().implicitlyWait(2, TimeUnit.SECONDS);
				}
			}


		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Exception to wait for element " + locator + " to be present");
			return status;
		}

		return status;

	}

	/**
	 * Binding to get Xpath, CSS, Link, Partial link element
	 *
	 * @param locator locator of element in xpath=locator; css=locator etc
	 * @return found WebElement
	 */
	public WebElement getElement(final String locator) {
		return getElement(locator, true);
	}


	/**
	 * Get "By" object to locate element
	 *
	 * @param locator locator of element in xpath=locator; css=locator etc
	 * @return by object
	 */
	public By byLocator(final String locator) {
		String prefix = locator.substring(0, locator.indexOf('='));
		String suffix = locator.substring(locator.indexOf('=') + 1);

		switch (prefix) {
		case "xpath":
			return By.xpath(suffix);
		case "css":
			return By.cssSelector(suffix);
		case "link":
			return By.linkText(suffix);
		case "partLink":
			return By.partialLinkText(suffix);
		case "id":
			return By.id(suffix);
		case "name":
			return By.name(suffix);
		case "tag":
			return By.tagName(suffix);
		case "className":
			return By.className(suffix);
		default:
			return null;
		}
	}

	/**
	 * @param locator          locator of element in xpath=locator; css=locator etc
	 * @param screenShotOnFail make screenshot on failed attempt
	 * @return found WebElement
	 */
	protected WebElement getElement(final String locator, boolean screenShotOnFail) {
		try {
			return driver.findElement(byLocator(locator));
		} catch (Exception e) {
			if (screenShotOnFail) ;
			throw e;
		}
	}
	/**
	 * Takes screenshot with default name
	 *
	 * @return url (or path for local machine) to saved screenshot
	 */
	/*protected String takeScreenshot() {
        return takeScreenshot(randomStringTime(23));
    }

	 *//**
	 * Takes screenshot of current page. Screenshots are placed in /screenshots directory of project's root
	 *
	 * @param fileName name to give for screenshot.
	 * @return url (or path for local machine) to saved screenshot
	 *//*
	 *//* protected String takeScreenshot(String fileName) {
        try {
            //Capture Screenshot
            TakesScreenshot driver = !getGrid() || getMobile() ?
                    (TakesScreenshot) Driver :
                    (TakesScreenshot) new Augmenter().augment(Driver);

            File tempFile = driver.getScreenshotAs(OutputType.FILE);
            saveAllureScreenshot(driver.getScreenshotAs(OutputType.BYTES));
            //Name and save file
            String path = getRelativeScreenshotPath(fileName);
            File screenShotFile = new File(path);
            FileUtils.copyFile(tempFile, screenShotFile);

            String strace = "";
            for (StackTraceElement el : Thread.currentThread().getStackTrace())
                strace += el.toString() + System.lineSeparator()
                        ;
            log.debug(strace);


            //Create link to screenshot
            String url = getScreenshotUrl(screenShotFile, fileName);
            log.info("SCREENSHOT: " + url);
            return url;

        } catch (Exception e) {
            //Suppress exception no need to fail test
            log.warn("takeScreenshot failed:", e);
            return e.getMessage();
        }
    }


	  *//**//**
	  * Composes url to screenshot that will be shown in build log
	  * In case of local build - result is screenshot local path
	  * In case of jenkins build - points to jenkins build artifacts
	  * <p>
	  * NOTE: url will become valid only after build is complete and results are archived
	  *
	  * @param screenShotFile
	  * @param fileName       name to give for screenshot.
	  * @return url (or path for local machine) to saved screenshot
	  *//**//*
    String getScreenshotUrl(File screenShotFile, String fileName) throws IOException {
        String url = null;
        if (isLocal()) {
            url = screenShotFile.getCanonicalPath();
        } else {
            url = System.getenv("BUILD_URL") + "/artifact/test_automation/" + getRelativeScreenshotPath(fileName);
        }

        return url;
    }

	   *//**/

	/**
	 * Composes relative path to screenshot file
	 *
	 * @param
	 * @return path
	 *//**//*
    String getRelativeScreenshotPath(String fileName) {
        String path = "screenshots/" + getScreenShotsDir() +
                "/" + Thread.currentThread().getName().replaceAll("\\(|\\)", "") + "/" + fileName + ".png";
        return path;
    }*/
	public boolean waitForElementPresent(String locator, int secs) {
		boolean status = false;
		try {
			WebDriverWait wait = new WebDriverWait(driver, secs);
            WebElement reqEle = wait.until(ExpectedConditions.visibilityOfElementLocated(byLocator(locator)));            
            status = (reqEle != null) ? true : false;
			//this.reporter.SuccessReport("Checked element present", "Successfully checked element present " + locator, Driver);
			//this.extentMngr.logResult(extentTC, Status.PASS, "Successfully checked element present " + locator);
            LogManager.logInfo(logClassName, "Successfully checked element present " + locator);
		} catch (TimeoutException te) {
			LogManager.logInfo(logClassName, "Timeout to check element present " + locator);
			status = false;
		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Exception to wait for element " + locator + " to be present");
			e.printStackTrace();
			status = false;
		}
		return status;
	}

	public boolean waitForElementNotPresent(String locator, int secs)  {
		boolean status = false;
		try {
			WebDriverWait wait = new WebDriverWait(driver, secs);
			wait.until(ExpectedConditions.invisibilityOfElementLocated(byLocator(locator)));
			status = true;
			//this.reporter.SuccessReport("Checked element absence", "Successfully checked element absence " + locator, Driver);
			//this.extentMngr.logResult(extentTC, Status.PASS, "Successfully checked element absence " + locator);
            LogManager.logInfo(logClassName, "Successfully checked element absence " + locator);
		} catch(TimeoutException te) { 
			LogManager.logInfo(logClassName, "Timeout to check element absence " + locator);
		}catch (Exception e) {
			//this.reporter.failureReport("Checked element absence", "Failed - " + locator + "present", Driver);            
			//this.extentMngr.logResult(extentTC, Status.FAIL, "Failed to checked element absence " + locator);
        	LogManager.logException(e, logClassName, "Failed to checked element absence " + locator);
			e.printStackTrace();
		}
		return status;
	}

	public boolean waitForElementToBeClickable(String locator, int secs)  {

		boolean flag = false;
		try {
			WebDriverWait wait = new WebDriverWait(driver, secs);
			wait.until(ExpectedConditions.elementToBeClickable(byLocator(locator)));
			flag = true;
		} catch(TimeoutException te) {
			LogManager.logInfo(logClassName, "Timeout to wait for element " + locator + " to be clickable");
		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Exception to wait for element " + locator + " to be clickable");
			e.printStackTrace();
		}
		return flag;
	}

	public void waitForElementToBeClickable(String locator)  {
		waitForElementToBeClickable(locator,gblConstants.wdWaitTimeout);
	}


	/**
	 * Soft wait for visibility of element with default timeout
	 *
	 * @param locator locator of element to wait for
	 * @return true if element is present and visible / false otherwise
	 */
	protected boolean waitForElementPresent(final String locator)  {
		return waitForElementPresent(locator, gblConstants.wdWaitTimeout);
	}

	/**
	 * Wait until element is invisible/not present on the page with default timeout
	 *
	 * @param locator locator to element
	 */
	protected void waitForElementNotPresent(final String locator)  {
		waitForElementNotPresent(locator, gblConstants.wdWaitTimeout);
	}


	/**
	 * Wait for invisibility of specific object on page
	 *
	 * @param locator of object that we wait for invisibility
	 */
	protected void waitForInvisibility(final String locator) {

		WebDriverWait wait = new WebDriverWait(driver, gblConstants.wdWaitTimeout);
		try {
			wait.until(ExpectedConditions.invisibilityOfElementLocated(byLocator(locator)));
		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to wait for element invisibility");
			//log.info("Try to wait little more (wait for invisibility)");
		}
	}

	/**
	 * Verifies whether element is present and displayed
	 *
	 * @param locator locator for element to verify
	 * @return true if present; false otherwise
	 */
	protected boolean isElementPresent(final String locator) {
		try {
			return isElementPresent(getElement(locator, false));
		} catch (Exception e) {
			return false;
		}
	}

	  /**
     * @Purpose To get Element presence 
     * @Constraints 
     * @Input String  : LocatorName and boolean presence
     * @Output boolean : Returns true | false
     */
    public boolean isElementPresent(String locatorName, boolean expected)  {
        boolean status = false;
        try {
            WebElement ele = getElement(locatorName);
            status = (ele.isDisplayed())? true : false;
        } catch (Exception e) {
            status = false;
        }
        if (!(expected ^ status)) {
            status = true;
            LogManager.logInfo(logClassName, "ElementFoundSuccess" + locatorName + " diplayed as " + expected);                
        } else {
            status = false;
            LogManager.logError(logClassName, "ElementFoundFailure" + locatorName + "Not Displayed " + expected);
        }        
        return status;
    }
    
	/**
	 * Binding to click the webElement
	 *
	 * @param we webElement to click
	 */
	protected void click(final WebElement we) {
		try {
			((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", we);
			we.click();
		} catch (Exception e) {
			//log.error("Failed to click:", e);
			//takeScreenshot();
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to click button");
			throw e;
		}
	}


	/**
	 * Binding to click Xpath, CSS, Link, Partial link element
	 *
	 * @param locator locator of the element in format xpath=locator; css=locator  etc
	 */
	protected void click(final String locator) {
		click(getElement(locator));
	}

	/**
	 * Verifies whether element is displayed
	 *
	 * @param we webelement to verify
	 * @return true if present; false otherwise
	 */

	protected boolean isElementPresent(final WebElement we) {

		try {

			return we.isDisplayed();

		} catch (Exception e) {

			return false;
			

		}

	}

	public void type(final WebElement we, String testdata)  {

		try {
			//((JavascriptExecutor) Driver).executeScript("arguments[0].scrollIntoView(true);", we);
			we.clear();
			we.sendKeys(testdata);
		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to enter text");
			throw e;
		}
	}

	public boolean type(String locatorName, String testdata)  {
		boolean blnRes = false;
		waitForElementPresent(locatorName, gblConstants.wdWaitTimeout);
		WebElement ele = getElement(locatorName);
		type(ele, testdata);
        LogManager.logInfo(WebActionEngine.class.getName(), "Successfully entered  " + testdata + " in element " + locatorName);
		if(ele.getAttribute("value").trim().equals(testdata.trim())){
			blnRes = true;
		}else{
			blnRes = false;
		}
		return blnRes;
	}

	public void type(String locatorName, String testdata, boolean clear, boolean keyClear)  {

		typeKeys(getElement(locatorName), testdata, clear, keyClear);
	}

	public void clickEnter(String locatorName)  {
		try {
			WebElement ele = getElement(locatorName);
			scrollElementIntoView(ele);
			ele.sendKeys(Keys.ENTER);
			LogManager.logInfo(logClassName, this.msgClickSuccess + locatorName);
		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to perform click  and enter");
			e.printStackTrace();
		}
	}

	/**
	 * @param locatorName: webelement having multiple elements
	 * @return list of webelements
	 * @throws Throwable
	 */
	public List<WebElement> getAllElements(String locatorName)  {


		List<WebElement> elements = new ArrayList<WebElement>();
		try {
			elements = driver.findElements(byLocator(locatorName));
			return elements;

		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to get elements");
			e.printStackTrace();
		}
		return elements;
	}

	/**
	 * Binding to check Checkbox
	 *
	 * @param we webElement of checkbox to check
	 */
	protected void check(final WebElement we) {
		if (!we.isSelected()) {
			we.click();
		}
	}

	/**
	 * Binding to check checkbox
	 *
	 * @param locator locator of checkbox to check
	 */
	protected void check(final String locator) {
		check(getElement(locator));
	}

	/**
	 * Binding to clear text field and enter text
	 *
	 * @param we       webElement to type to
	 * @param value    value to type into the field
	 * @param clear    true to clear the field first; false to enter text without clearing field
	 * @param keyClear true to clean using keyboard shortcut; false without clean;
	 * @return webElement with edited text
	 */
	protected WebElement typeKeys(final WebElement we, final String value, final boolean clear, final boolean keyClear) {
		if (clear) we.clear();
		if (keyClear) {
			we.sendKeys(Keys.chord(Keys.CONTROL, "a"));
			we.sendKeys(Keys.chord(Keys.DELETE));
		}
		we.sendKeys(value);
		return we;
	}

	public String getVisibleText(final String locator)  {
		String text = "";
		try {
			WebElement ele = getElement(locator); 
			text = ele.getText();
			return text;
		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to get visibile text");
			e.printStackTrace();
		}
		return "";
	}

	public String getAttributeValue(final String locator, final String attribute){
		String value = "";
		WebElement we = getElement(locator);
		return we.getAttribute(attribute);
	}

	/**
	 * Binding to select item in dropdown which needs to be clicked for edit mode.
	 * Fills actual value and presses "TAB" to submit, otherwise value could be not saved
	 *
	 * @param clickE        webElement of the field to click
	 * @param selectLocator locator of the dropdown
	 * @param value         value to select
	 */
	protected void clickToSelect(final WebElement clickE, final String selectLocator, final String value) {
		click(clickE);
		selectDropDown(getElement(selectLocator), value);
		getElement(selectLocator).sendKeys(Keys.TAB);
	}

	/**
	 * Binding to select item in dropdown by value
	 *
	 * @param we     WebElement of the dropdown
	 * @param option value to select in the dropdown
	 */
	protected void selectDropDown(final WebElement we, final String option) {

		try {
			getSelect(we).selectByVisibleText(option);
		} catch (Exception e) {
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to select option from dropdown");
			//takeScreenshot();
			throw e;
		}
	}

	protected void selectDropDown(By locator, String option, String locatorName)  {

		try {
			WebDriverWait wait = new WebDriverWait(driver, gblConstants.wdWaitTimeout);
			wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
			new Select(driver.findElement(locator)).selectByVisibleText(option);
			//this.reporter.SuccessReport("Drop Down Selection " + locatorName, "Successfully Selected " + option + " in drop down " + locatorName, this.Driver);
			//this.extentMngr.logResult(extentTC, Status.PASS, "Successfully Selected " + option + " in drop down " + locatorName);
            LogManager.logInfo(logClassName, "Successfully Selected " + option + " in drop down " + locatorName);
			//logger.log(Status.PASS, "Successfully Selected " + option + " in drop down " + locatorName, logger.addScreenCapture(capture(Driver, "DropdownPass")));
		} catch (Exception e) {
			//this.reporter.failureReport("Drop Down Selection " + locatorName, "Failed to select value" + option + " in drop down " + locatorName, this.Driver);
			//this.extentMngr.logResult(extentTC, Status.FAIL, "Failed to select value" + option + " in drop down " + locatorName);
        	LogManager.logException(e, logClassName, "Failed to select value" + option + " in drop down " + locatorName);
			throw e;
		}
	}

	protected Select getSelect(final WebElement we) {
		return new Select(we);
	}

	public void scrollElementIntoView(String locator) {
		((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", getElement(locator));
	}

	public void scrollElementIntoView(WebElement elementToScroll) {
		((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", elementToScroll);
	}

	public String timeStamp() {
		/*java.util.Date today = new java.util.Date();
		return new java.sql.Timestamp(today.getTime()).toString();*/
		Date now = new Date();
		String time = new SimpleDateFormat("dd-MM-yyyy HH:mm", Locale.ENGLISH).format(now);
		System.out.println(time);
		return time;
	}

	public void typeUsingJavaScript(String locator, String data) {

		WebElement element = this.driver.findElement(byLocator(locator));
		JavascriptExecutor executor = (JavascriptExecutor) driver;
		executor.executeScript("arguments[0].value='" + data + "';", element);
	}
	
	public void typeUsingJavaScriptInHTMLInnerText(String locator, String data) {

		WebElement element = this.driver.findElement(byLocator(locator));
		JavascriptExecutor executor = (JavascriptExecutor) driver;
		
		executor.executeScript("arguments[0].innerHTML = +data+'", element);
		
	}

	//    public void assertTrue(ExtentTest extentTC, boolean condition, String message, String strStepName, String failedMessage, String passMessage) throws Throwable {
	//        if (!condition) {
	//        	//this.reporter.failureReport(strStepName, failedMessage, Driver);        	
	//            this.extentMngr.logResult(extentTC, Status.FAIL, failedMessage);
	//            this.extentMngr.attachScreenshot(extentTC, Status.FAIL, captureScreenShot("assertTrue_Fail"));
//            LogManager.logError(logClassName, "Assertion failure with message " + failedMessage);
	//            Assert.assertTrue(condition, message);
	//        } else {
	//            this.extentMngr.logResult(extentTC, Status.PASS, failedMessage);
//            LogManager.logInfo(logClassName, "Assertion pass with message " + passMessage);
	//        	//this.reporter.SuccessReport(strStepName, passMessage, Driver);
	//        }
	//    }
	//
	//    public void assertFalse(ExtentTest extentTC, boolean condition, String message, String strStepName, String failedMessage, String passMessage) throws Throwable {
	//        if (condition) {
	//            //this.reporter.failureReport(strStepName, failedMessage, Driver);
	//            this.extentMngr.logResult(extentTC, Status.FAIL, failedMessage);
	//            this.extentMngr.attachScreenshot(extentTC, Status.FAIL, captureScreenShot("assertFalse_Fail"));
//            LogManager.logError(logClassName, "Assertion failure with message " + failedMessage);
	//            Assert.assertFalse(condition, message);
	//        } else {
	//            //this.reporter.SuccessReport(strStepName, passMessage, Driver);        	
	//            this.extentMngr.logResult(extentTC, Status.PASS, passMessage);
//            LogManager.logInfo(logClassName, "Assertion pass with message " + passMessage);        	
	//        }
	//    }
	//
	//    public void assertEqual(ExtentTest extentTC, String actual, String expected, String message, String strStepName, String failedMessage, String passMessage) throws Throwable {
	//        if (!actual.equals(expected)) {
	//            //this.reporter.failureReport(strStepName, failedMessage, Driver);
	//            this.extentMngr.logResult(extentTC, Status.FAIL, failedMessage);
	//            this.extentMngr.attachScreenshot(extentTC, Status.FAIL, captureScreenShot("assertEqual_Fail"));
//            LogManager.logError(logClassName, "Assertion failure with message " + failedMessage);        	
	//            Assert.assertEquals(actual, expected, message);
	//        } else {
	//        	//this.reporter.SuccessReport(strStepName, passMessage, Driver);
	//        	this.extentMngr.logResult(extentTC, Status.PASS, passMessage);
//            LogManager.logInfo(logClassName, "Assertion pass with message " + passMessage);         	            
	//        }
	//    }
	//
	//    public void assertEqual(ExtentTest extentTC, int actual, int expected, String message, String strStepName, String failedMessage, String passMessage) throws Throwable {
	//        if (actual == expected) {
	//            //this.reporter.failureReport(strStepName, failedMessage, Driver);
	//            this.extentMngr.logResult(extentTC, Status.FAIL, failedMessage);
	//            this.extentMngr.attachScreenshot(extentTC, Status.FAIL, captureScreenShot("assertEqual_Fail"));
//            LogManager.logError(logClassName, "Assertion failure with message " + failedMessage);         	
	//            Assert.assertEquals(actual, expected, message);
	//        } else {
	//        	//this.reporter.SuccessReport(strStepName, passMessage, Driver);
	//        	this.extentMngr.logResult(extentTC, Status.PASS, passMessage);
//            LogManager.logInfo(logClassName, "Assertion pass with message " + passMessage);            	
	//        }
	//    }

	public void highlight(String locator) {
		WebElement elem = getElement(locator);
		((JavascriptExecutor) driver).executeScript("arguments[0].style.border='6px solid yellow'", elem);
		((JavascriptExecutor) driver).executeScript("arguments[0].style.border='6px solid red'", elem);
		((JavascriptExecutor) driver).executeScript("arguments[0].style.border='6px solid blue'", elem);
		((JavascriptExecutor) driver).executeScript("arguments[0].style.border='0px solid green'", elem);
	}

	public void waitForGivenNumberOfWindowsToOpen(int expectedWindowsCount, int timeUnitsInSec) throws InterruptedException {
		int actualWindowsCount = driver.getWindowHandles().size();
		for (int i = 0; i < timeUnitsInSec; i++) {
			Thread.sleep(1000);
			if (expectedWindowsCount == actualWindowsCount)
				break;
		}
	}

	public String captureScreenShot(String strReportsPath, String strSSName) {
		try{
			TakesScreenshot ts = (TakesScreenshot) this.driver;
			File source = ts.getScreenshotAs(OutputType.FILE);
			String epoch2 = String.valueOf(System.currentTimeMillis() / 1000);
			//String strSSRelativePath = "/extent_reports/screenshots/" + screenShotName + "_" + epoch2 + "_" + ".png";
			//String strSSRelativePath = "." + File.separator + gblConstants.screenshotDirName + 
			//		File.separator + strSSName + "_" + epoch2 + "_" + ".png";
			strSSName = strSSName + "_" + epoch2 + ".png";
			String dest = strReportsPath + File.separator + gblConstants.screenshotDirName + File.separator + strSSName;
			File destination = new File(dest);
			FileUtils.copyFile(source, destination);

			return strSSName;
		}catch(IOException io){
    		LogManager.logException(io, WebActionEngine.class.getName(), "Exception to capture screenshot");
			return "";
		}catch(Exception e){
    		LogManager.logException(e, WebActionEngine.class.getName(), "Exception to capture screenshot");
			return "";
		}
	}

	public boolean switchToWindowContainingTitle(String expTitle, boolean refresh){
		boolean blnRes = false;
		//Work around in OMS - Monitor for consistency
		if(refresh){
			driver.manage().window().maximize();
		}
		System.out.println(driver.getWindowHandles().size());
		Iterator<String> wndHandles = driver.getWindowHandles().iterator(); 
		int ii = 0;
		while(wndHandles.hasNext()){
			String wndHandle = wndHandles.next();
			String currWndTitle = "";

			this.driver.switchTo().window(wndHandle);
			currWndTitle = this.driver.getTitle().trim(); ii++;
			LogManager.logInfo(WebActionEngine.class.getName(), "Window Title -" + ii +"->  " + currWndTitle);
			if(currWndTitle.toLowerCase().contains(expTitle.trim().toLowerCase())){
				blnRes = true;
    			LogManager.logInfo(WebActionEngine.class.getName(), "Switching to window containing title " + expTitle);
				break;
			}
		}
		if(blnRes == false){
    		LogManager.logInfo(WebActionEngine.class.getName(), "Unable to Switch to window containing title " + expTitle);
		}
		return blnRes;
	}
	
	public boolean switchToWindowContainingNoTitle(boolean refresh) {
		boolean blnRes = false;
		//Work around in OMS - Monitor for consistency
		if(refresh){
			driver.manage().window().maximize();
		}
		System.out.println(driver.getWindowHandles().size());
		Iterator<String> wndHandles = driver.getWindowHandles().iterator(); 
		int ii = 0;
		while(wndHandles.hasNext()){
			String wndHandle = wndHandles.next();
			this.driver.switchTo().window(wndHandle);
			String  currWndTitle = this.driver.getTitle().trim(); ii++;
			LogManager.logInfo(WebActionEngine.class.getName(), "Window Title -" + ii +"->  " + currWndTitle);
			if (currWndTitle.toLowerCase().trim().isEmpty()) {
				blnRes = true;
    			LogManager.logInfo(WebActionEngine.class.getName(), "Switching to window having no title");
				break;
			}
		}
		if (blnRes == false) {
    		LogManager.logInfo(WebActionEngine.class.getName(), "Unable to Switch to window no title ");
		}
		return blnRes;
	}

	public String switchToDefaultContent(){
		this.driver.switchTo().defaultContent();
		return this.driver.getTitle();
	}

	public boolean typeUsingKeyBoard(String locatorName, String testdata)  {
		boolean blnRes = false;
		WebElement ele = getElement(locatorName);
		ele.sendKeys(Keys.SHIFT,testdata);
		LogManager.logInfo(WebActionEngine.class.getName(), "Successfully entered  " + testdata + " in element " + locatorName);

		if(ele.getAttribute("value").trim().equalsIgnoreCase(testdata.trim())){
			blnRes = true;
		}else{
			blnRes = false;
		}
		return blnRes;
	}
	
	public String getDefaultContentWindowHandle() {
		return this.driver.switchTo().defaultContent().getWindowHandle();
	}
	
	public boolean moveFocusToElement(String locator) {
		boolean blnRes = false;
		try {
			WebElement element = this.driver.findElement(byLocator(locator));
			JavascriptExecutor executor = (JavascriptExecutor) driver;
			executor.executeScript("element.focus();");
			Thread.sleep(500);
			blnRes = true;
		} catch(Exception e){
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to move focus element");
			blnRes = false;
   		}
		return blnRes;
	}
	
	public boolean saveDownloadFiles(String fileName) {
		boolean blnRes = false;
		try {
			//this.switchToWindowContainingTitle(pageTitle, true);
			Thread.sleep(10000); //wait for file to download completely
			 Robot robot = new Robot();  
	           robot.keyPress(KeyEvent.VK_CONTROL);
	           robot.keyPress(KeyEvent.VK_SHIFT);
	           robot.keyPress(KeyEvent.VK_S);
	           robot.keyRelease(KeyEvent.VK_S);
	           robot.keyRelease(KeyEvent.VK_SHIFT);
	           robot.keyRelease(KeyEvent.VK_CONTROL);
	           Thread.sleep(2000);
	           StringSelection dwnldPath = new StringSelection(gblConstants.downloadsPath +File.separator+fileName);
	           LogManager.logInfo(WebActionEngine.class.getName(), "Downloaded file is "+fileName);
	           Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
	           clipboard.setContents(dwnldPath, dwnldPath);
	          
	           //copy paste the path in download window
	           robot.keyPress(KeyEvent.VK_CONTROL);
	           robot.keyPress(KeyEvent.VK_V);
	           robot.keyRelease(KeyEvent.VK_V);
	           robot.keyRelease(KeyEvent.VK_CONTROL);
	           robot.keyPress(KeyEvent.VK_TAB);  
	           robot.keyPress(KeyEvent.VK_TAB); 
	           robot.keyPress(KeyEvent.VK_TAB); 
	           robot.keyPress(KeyEvent.VK_ENTER);
	           robot.keyRelease(KeyEvent.VK_ENTER);
	           robot.keyRelease(KeyEvent.VK_TAB);
	           
		}catch(Exception e){
			blnRes = false;
			LogManager.logException(e, WebActionEngine.class.getName(), "Unable to perform download");
   		}
		return blnRes;
	}
	
	
}
